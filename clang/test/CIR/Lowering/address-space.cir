// RUN: cir-translate %s -cir-to-llvmir --target spirv64-unknown-unknown --disable-cc-lowering -o %t.ll
// RUN: FileCheck --input-file=%t.ll %s -check-prefix=LLVM

!s32i = !cir.int<s, 32>

module {
  cir.global external lang_address_space(offload_global) @addrspace1 = #cir.int<1> : !s32i
  // LLVM: @addrspace1 = addrspace(1) global i32

  cir.global "private" internal lang_address_space(offload_local) @addrspace2 : !s32i
  // LLVM: @addrspace2 = internal addrspace(3) global i32 undef

  cir.global external target_address_space(7) @addrspace3 = #cir.int<3> : !s32i
  // LLVM: @addrspace3 = addrspace(7) global i32

  // Test GlobalViewAttr with address space cast.
  cir.global external target_address_space(1) @global_in_as1 = #cir.int<42> : !s32i
  // LLVM: @global_in_as1 = addrspace(1) global i32 42

  // Reference to @global_in_as1 with a pointer in default address space (0)
  cir.global external @ref_with_addrspacecast = #cir.const_array<[#cir.global_view<@global_in_as1> : !cir.ptr<!cir.void>]> : !cir.array<!cir.ptr<!cir.void> x 1>
  // LLVM: @ref_with_addrspacecast = global [1 x ptr] [ptr addrspacecast (ptr addrspace(1) @global_in_as1 to ptr)]

  // LLVM: define void @foo(ptr %0)
  cir.func @foo(%arg0: !cir.ptr<!s32i>) {
    // LLVM-NEXT: alloca ptr,
    %0 = cir.alloca !cir.ptr<!s32i>, !cir.ptr<!cir.ptr<!s32i>>, ["arg", init] {alignment = 8 : i64}
    cir.return
  }

  // LLVM: define void @bar(ptr addrspace(1) %0)
  cir.func @bar(%arg0: !cir.ptr<!s32i, target_address_space(1)>) {
    // LLVM-NEXT: alloca ptr addrspace(1)
    %0 = cir.alloca !cir.ptr<!s32i, target_address_space(1)>, !cir.ptr<!cir.ptr<!s32i, target_address_space(1)>>, ["arg", init] {alignment = 8 : i64}
    cir.return
  }

  // LLVM: define void @baz(ptr %0)
  cir.func @baz(%arg0: !cir.ptr<!s32i, target_address_space(0)>) {
    // LLVM-NEXT: alloca ptr,
    %0 = cir.alloca !cir.ptr<!s32i, target_address_space(0)>, !cir.ptr<!cir.ptr<!s32i, target_address_space(0)>>, ["arg", init] {alignment = 8 : i64}
    cir.return
  }

  // LLVM: define void @test_lower_offload_as()
  cir.func @test_lower_offload_as() {
    %0 = cir.alloca !cir.ptr<!s32i, lang_address_space(offload_private)>, !cir.ptr<!cir.ptr<!s32i, lang_address_space(offload_private)>>, ["arg0", init] {alignment = 8 : i64}
    // LLVM-NEXT: alloca ptr,
    %1 = cir.alloca !cir.ptr<!s32i, lang_address_space(offload_global)>, !cir.ptr<!cir.ptr<!s32i, lang_address_space(offload_global)>>, ["arg1", init] {alignment = 8 : i64}
    // LLVM-NEXT: alloca ptr addrspace(1),
    %2 = cir.alloca !cir.ptr<!s32i, lang_address_space(offload_constant)>, !cir.ptr<!cir.ptr<!s32i, lang_address_space(offload_constant)>>, ["arg2", init] {alignment = 8 : i64}
    // LLVM-NEXT: alloca ptr addrspace(2),
    %3 = cir.alloca !cir.ptr<!s32i, lang_address_space(offload_local)>, !cir.ptr<!cir.ptr<!s32i, lang_address_space(offload_local)>>, ["arg3", init] {alignment = 8 : i64}
    // LLVM-NEXT: alloca ptr addrspace(3),
    %4 = cir.alloca !cir.ptr<!s32i, lang_address_space(offload_generic)>, !cir.ptr<!cir.ptr<!s32i, lang_address_space(offload_generic)>>, ["arg4", init] {alignment = 8 : i64}
    // LLVM-NEXT: alloca ptr addrspace(4),
    cir.return
  }
}
